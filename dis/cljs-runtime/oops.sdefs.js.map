{"version":3,"file":"oops.sdefs.js","sources":["oops/sdefs.cljs"],"mappings":";;;ojCASgCgB,pjCADhC,AAAAhB,yBAAA,+EAAA,eAAA,kFAAA,0DAAA,iFAAA,0DAAA,kFAAiB,AAAAW,6BAAA,mFAAA,0DAAA,kEAAA,mFAAA,iFAAA,yFAAA,4IAAA,zDAAcM;i0CAGO,AAAAN,6BAAA,mFAAA,sDAAA,6EAAA,mFAAA,eAAA,iFAAA,wFAAA,eAAA,uEAAA,mFAAA,2DAAA,eAAA,sEAAA,eAAA,+EAAA,oDAAA,eAAA,8EAAA,eAAA,gFAAA,0FAAA,wFAAA,8DAAA,mFAAA,AAAAF,yBAAA,uFAAA,wFAAA,WAAAG,59FADtC,AAAAZ,yBAAA,uFAAA,eAAA,kFAAA,oDAAA,+EAAA,4DAAA,eAAA,uFAAA,yFAAsB,AAAAW,6BAAA,mFAAA,oDAAA,oEAAA,mFAAA,+EAAA,eAAA,uFAAA,gGAAA,mFAAA;AACgB,AAAA,SAAA,AAAAT,uBAAAU,+BAAA,AAAAC,uBAAA,AAAAC,gDAAAC,6BAAA,wFAAAH;WAAA,cADhB;AAOtB,AAAAZ,yBAAA,0FAAA,+CAAA,eAAA,iFAAA,eAAA,kFAAA,eAAA,iFAAA,mGAAyB,lBAAiB,SAAkB;AAC5D,AAAAA,yBAAA,yFAAA,iFAAsBiB;AACtB,AAAAjB,yBAAA,yFAAA,eAAA,wFAAA,0FAAA,0FAAuB,AAAAU,yDAAA,mFAAA,0FAAA,iGAAA,mFAAA,0FAAA;AACvB,AAAAV,yBAAA,+EAAA,eAAA,qFAAA,+EAAA,eAAA,uEAAA,mFAAA,+DAAA,eAAA,wEAAA,mFAAA,4DAAA,eAAA,wEAAA,uEAAA,eAAA,4FAAA,IAAA,iEAAA,eAAA,0FAAA,eAAA,iFAAA,0FAAA,gEAAkB,AAAAC,8BAAA,mFAAA,+EAAA,eAAA,uEAAA,mFAAA,+DAAA,eAAA,wEAAA,mFAAA,4DAAA,eAAA,wEAAA,uEAAA,eAAA,4FAAA,IAAA,iEAAA,eAAA,0FAAA,eAAA,iFAAA,0FAAA,uEAAA,mFAAOC,uBAAO,WAAKC;AAAL,AACE,IAAMC,QAAM,AAACC,4CAAIC,cAAI,sDAAA,tDAACC,0DAAgBJ;AAAtC,AACE,OAACK,2DAAS,AAAAC,yBAAA,yFAAA,0FAAsBL;WAFlD","names":["cljs.spec.alpha/def-impl","cljs.spec.alpha/and-spec-impl","cljs.core/array?","arr","pairs","cljs.core.map.cljs$core$IFn$_invoke$arity$2","cljs.core/vec","cljs.core.partition_all.cljs$core$IFn$_invoke$arity$2","cljs.spec.alpha.valid_QMARK_.cljs$core$IFn$_invoke$arity$2","cljs.spec.alpha/rep-impl","cljs.spec.alpha.tuple_impl.cljs$core$IFn$_invoke$arity$2","cljs.spec.alpha/or-spec-impl","p1__20753__20754__auto__","cljs.core/every?","cljs.core.partial.cljs$core$IFn$_invoke$arity$2","cljs.spec.alpha/valid?","cljs.core/keyword?","cljs.core/string?"],"sourcesContent":["(ns oops.sdefs\n  \"Spec definitions for our dynamic code.\"\n  (:require-macros [oops.constants :refer [get-dot-access get-soft-access get-punch-access]]\n                   [oops.spec :refer [native-array-aware-*]])\n  (:require [clojure.spec.alpha :as s]))\n\n; --- specs -----------------------------------------------------------------------------------------------------------------\n\n(s/def ::obj-key (s/or :string string?\n                       :keyword keyword?))\n(s/def ::obj-selector (s/or :key ::obj-key\n                            :selector (native-array-aware-* ::obj-selector)))\n\n; note: ::obj-path is a native array for performance reasons\n;       it is not a sequence of tuples, but it is flat sequence of pairs mode-key\n;       for an example clj path [[0 \"key1\"] [0 \"key2\"] ...]\n;       the equivalent cljs path is [0 \"key1\" 0 \"key2\"]\n(s/def ::obj-path-mode #{(get-dot-access) (get-soft-access) (get-punch-access)})\n(s/def ::obj-path-key string?)\n(s/def ::obj-path-item (s/tuple ::obj-path-mode ::obj-path-key))\n(s/def ::obj-path (s/and array? (fn [arr]\n                                  (let [pairs (map vec (partition-all 2 arr))]\n                                    (s/valid? (s/* ::obj-path-item) pairs)))))\n"]}