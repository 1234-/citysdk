{"version":3,"file":"linked.set.js","sources":["linked/set.cljc"],"mappings":"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","names":["cljs.core/set?","other","coll","v","this","o","linked.set/LinkedSet","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","linked-map","not-found","temp__5457__auto__","s","cljs.core/key","cljs.core/seq","cljs.core.map.cljs$core$IFn$_invoke$arity$2","meta","cljs.core/with-meta","k","_","cljs.core/hash","cljs.core.into.cljs$core$IFn$_invoke$arity$2","linked.map/empty-linked-map","self__","args25440","cljs.core/aclone","this__4192__auto__","writer__4193__auto__","opt__4194__auto__","cljs.core/-write","linked.set/->LinkedSet","cljs.core/-dissoc","writer","opts","cljs.core/rseq","cljs.core/count","linked.set/empty-linked-set","cljs.core/-count","p1__25438#","cljs.core/every?","cljs.core/contains?","cljs.core/-contains-key?","cljs.reader/register-tag-parser!","linked.set/->linked-set","cljs.core/meta","clojure.string.join.cljs$core$IFn$_invoke$arity$2","cljs.core/str","cljs.core.partial.cljs$core$IFn$_invoke$arity$2","cljs.core/into"],"sourcesContent":["(ns linked.set\n  (:require [linked.map :refer [empty-linked-map]]\n            [clojure.string :as string]\n    #?(:cljs [cljs.reader :as reader]))\n  #?(:clj\n     (:import (clojure.lang Counted\n                            IObj\n                            IFn\n                            IHashEq\n                            ILookup\n                            IPersistentCollection\n                            IPersistentSet\n                            IPersistentVector\n                            Reversible\n                            Seqable\n                            SeqIterator)\n              (java.util Set)\n              (java.lang Iterable))))\n\n(declare empty-linked-set)\n\n(deftype LinkedSet [linked-map]\n  #?@(:clj\n      [IPersistentSet\n       (disjoin [_ k]\n         (LinkedSet. (dissoc linked-map k)))\n       (contains [_ k]\n         (contains? linked-map k))\n       (get [this k]\n         (when (.contains this k) k))\n\n       Set\n       (size [this]\n         (.count this))\n\n       Iterable\n       (iterator [this]\n         (SeqIterator. (.seq this)))\n\n       Counted\n\n       IPersistentCollection\n       (count [_]\n         (count linked-map))\n       (cons [this o]\n         (if (contains? linked-map o)\n           this\n           (LinkedSet. (assoc linked-map o nil))))\n       (empty [_]\n         empty-linked-set)\n       (equiv [this other]\n         (or (identical? this other)\n             (and (instance? Set other)\n                  (let [^Set s other]\n                    (and (= (.size this) (.size s))\n                         (every? #(.contains s %) (.seq this)))))))\n       Seqable\n       (seq [_]\n         (when-let [s (seq linked-map)] (map key s)))\n\n       Reversible\n       (rseq [_]\n         (when-let [s (rseq linked-map)] (map key s)))\n\n       IFn\n       (invoke [this k]\n         (get this k))\n\n       IObj\n       (meta [this]\n         (.meta ^IObj linked-map))\n       (withMeta [this m]\n         (LinkedSet. (.withMeta ^IObj linked-map m)))\n\n       IHashEq\n       (hasheq [this] (.hasheq ^IHashEq (into #{} this)))\n\n       Object\n       (toString [this]\n         (str \"[\" (string/join \" \" (map str this)) \"]\"))\n       (hashCode [this]\n         (.hashCode ^Object (into #{} this)))\n       (equals [this other]\n         (.equiv this other))]\n      :cljs\n      [Object\n       (toString [this]\n                 (str \"[\" (string/join \" \" (map str this)) \"]\"))\n       (equiv [this other]\n              (-equiv this other))\n\n       ICloneable\n       (-clone [_] (LinkedSet. linked-map))\n\n       IWithMeta\n       (-with-meta [coll meta] (LinkedSet. (with-meta linked-map meta)))\n\n       IMeta\n       (-meta [coll] (meta linked-map))\n\n       ICollection\n       (-conj [coll o]\n              (LinkedSet. (assoc linked-map o nil)))\n\n       IEmptyableCollection\n       (-empty [coll] (with-meta empty-linked-set meta))\n\n       IEquiv\n       (-equiv [coll other]\n               (and\n                 (set? other)\n                 (== (count coll) (count other))\n                 (every? #(contains? coll %)\n                         other)))\n\n       IHash\n       (-hash [coll] (hash (into #{} coll)))\n\n       ISeqable\n       (-seq [coll] (when-let [s (seq linked-map)] (map key s)))\n\n       IReversible\n       (-rseq [coll] (when-let [s (rseq linked-map)] (map key s)))\n\n       ISequential\n\n       ICounted\n       (-count [coll] (-count linked-map))\n\n       ILookup\n       (-lookup [coll v]\n                (-lookup coll v nil))\n       (-lookup [coll v not-found]\n                (if (-contains-key? linked-map v)\n                  v\n                  not-found))\n\n       ISet\n       (-disjoin [coll v]\n                 (LinkedSet. (-dissoc linked-map v)))\n\n       IFn\n       (-invoke [coll k]\n                (-lookup coll k))\n       (-invoke [coll k not-found]\n                (-lookup coll k not-found))\n\n       ;; IEditableCollection\n\n       IPrintWithWriter\n       (-pr-writer [coll writer opts]\n                   (-write writer (str \"#linked/set \" (into [] coll))))]))\n\n#?(:clj\n   (defmethod print-method LinkedSet [o ^java.io.Writer w]\n     (.write w \"#linked/set \")\n     (print-method (into [] o) w)))\n\n(def ^{:tag LinkedSet} empty-linked-set\n  (LinkedSet. empty-linked-map))\n\n(def ->linked-set (partial into empty-linked-set))\n\n#?(:cljs (reader/register-tag-parser! 'linked/set ->linked-set))\n"]}