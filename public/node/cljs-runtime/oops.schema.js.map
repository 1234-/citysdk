{"version":3,"file":"oops.schema.js","sources":["oops/schema.cljs"],"mappings":";;AAYA,iCAAA,jCAAK8B;AACL,AAAKJ,kCAAoB,KAAAC,OAAA,UAAA;AACzB,AAAKF,yCAA2B,KAAAE,OAAA,sBAAA;AAEhC,iCAAA,jCAAMc,0EAAoBjB;AACxB,iBAAA,YAAA,tBAAUA,PADZ;;AAGA,2CAAA,3CAAMZ,8FAAyBH,YAAYN;AACzC,GAAU,AAACK,uBAAOC,1BADpB;AACE;;AAAA,AACE,IAAAc,WAAM,AAACT,gBAAML;AAAb,AAAA,QAAAc;KAAA;AACM,AACE,AAAOpB,SAAI;;AACX,OAAOA,SAAI,sBAAA,tBAAYM;;;KAH/B;AAIM,AACE,AAAON,SAAI;;AACX,OAAOA,SAAI,sBAAA,tBAAYM;;;;AAE3B,AAAON,SAAI,TADb;;AAEE,OAAOA,SAAI,AAACsC,+BAAmBhC;;;;;AAEvC,4BAAA,5BAAMI,gEAAeW;AAArB,AACE,wDAAA,jDAAUA,UAAEC;;AAEd,0CAAA,1CAAMU,4FAAwBN,aAAa1B;AACzC,IAAMyB,eAAa,2FAAA,3FAAQ,AAAUC,qBAAaH,gCAAoBI,xEADxE;AACE,AACE,IAAOnB,QAAM,AAACyB,cAAIR;;AAChB,GAAMjB,HADR;AAEI,AAACC,yCAAwB,AAACC,0BAAc,AAACC,gBAAMH,QAAQR,3FADzD;;AAEE,eAAO,AAACO,eAAKC;;;;AAFf;;;;;AAIN,2CAAA,3CAAMgC,8FAAyBT,IAAI/B;AACjC,IAAM0B,eAAa,AAACI,eAAKC,lCAD3B;AACE,AACE,OAACC,wCAAuBN,aAAa1B;;AAEzC,oDAAA,pDAAMY,gHAAkCC,KAAKb;AAA7C,AACE,IAAOQ,QAAM,AAACyB,cAAIpB;;AAChB,GAAM,EAAA,UAAA,TAAOL,NADf;AACE,AACE,IAAMW,OAAK,AAACwB,iBAAOnC;AACjB,GAAI,AAACU,4BAAYC,/BADnB;AAEI,CAACP,kFAAAA,4FAAAA,ZAAiCO,wEAAAA,nEAAKnB,wEAAAA;;AACvC,AAACwC,yCAAwBrB,KAAKnB;;;AAChC,eAAO,AAACO,eAAKC;;;;AALjB;;;;;AAOJ,yCAAA,zCAAMT,0FAAsBC,IAAIH;AAAhC,AACE,SAAK,YAAA,XAAM,CAAgBG,IAAIH,gBAC1B,6CAAA,7CAACuC,gDAAK,CAAgBpC,IAAI,KAAA,JAAKH;;AAEtC,8CAAA,9CAAMO,oGAA4BJ,IAAIH;AAAtC,AACE,CAAMG,IAAI,KAAA,JAAGH,YAAK,CAAgBG,IAAIH;;AACtC,oBAAA,bAASG,WAAIH;;AAEf,+CAAA,/CAAMqC,sGAA6BlC;AACjC,IAAMF,MAAI,AAASE,VADrB;AAEI,IAAOH,IAAE,OAAA,NAAGC,TADd;;AACE,AACE,IAAMG,SAAO,KAAA,JAAGJ;AAAhB,AACE,GAAI,UAAA,TAAMI;AACRD;;AAEE,oBAAM,AAACD,uCAAqBC,IAAIC,/DADlC;AACE,AACE,AAACG,4CAA2BJ,IAAIC;;AADlC;;AAEA,eAAOA;;;;;;;AAEnB,iCAAA,jCAAMC,0EAAeC,SAASH;AAA9B,AACE,AAACY,kDAAiCT,SAASH;;AAC3C,OAACkC,6CAA4BlC;;AAE/B,wCAAA,xCAAMqC,wFAAsBN,IAAI/B;AAAhC,AACE,OAACwC,yCAAwBT,IAAI/B;;AAE/B,kDAAA,lDAAMe,4GAA+BC,KAAKuB;AACxC,IAAO/B,QAAM,AAACyB,cAAIjB,1BADpB;;AACE,AACE,GAAMR;AAAN,AACE,oBAAI,iBAAAoC,WAAW,AAACjC,gBAAMH;AAAlB,AAAA,sGAAAoC,sCAAAA,pIAACL,gDAAAA,0DAAAA;;AACH,eAAO,AAAChC,eAAK,AAACA,eAAKC;;;;AADrB;;;AADF;;;;;AAMJ,uCAAA,vCAAMoB,sFAAqBZ,KAAKa;AAC9B,AADF;AAEE;AACA,GAAI,AAACxB,uBAAOW;AAAZ,0FAAA;;AAEE,IAAAyB,WAAMZ;AAAN,AAAA,QAAAY;KAAA;AACI,oBAAM,qDAAA,rDAAC1B,gDAA8BC;kBAA/BF;AAAA,AAAqC,uDAAAA,hDAACG,iEAAO;;;AAAnD,AAAA,0FAAA;;AAAA;;;;KADJ;AAGI,oBAAM,qDAAA,rDAACF,gDAA8BC;kBAA/BmB;AAAA,AAAqC,uDAAAA,hDAAClB,iEAAO;;;AAAnD,AAAA,0FAAA;;AAAA;;;;;AAHJ,MAAA,KAAAyB,MAAA,CAAA,mEAAAD","names":["i","len","oops.schema/standalone-modifier?","arr","finger","oops.schema/prepare-path!","selector","oops.schema/merge-standalone-modifier!","cljs.core/empty?","element-str","cljs.core/next","items","oops.schema/parse-selector-element!","oops.schema/unescape-dots","cljs.core/first","oops.schema/collect-coerced-keys-into-array!","coll","p1__22180#","oops.schema/has-invalid-path-access-mode?","path","cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core/sequential?","item","G__22173","s","oops.schema/re-all-escaped-dot-markers","oops.schema/re-all-escaped-dots","js/RegExp","elements-arr","selector-str","oops.schema/escaped-dot-marker","oops.schema/check-dynamic-path!","op","cljs.core/name","key","oops.schema/parse-selector-string!","cljs.core/seq","oops.schema/merge-standalone-modifiers!","p1__22181#","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","oops.schema/prepare-simple-path!","oops.schema/unescape-modifiers","is-valid?","oops.schema/coerce-key-dynamically!","G__22182","js/Error","cljs.core/-first","G__22178"],"sourcesContent":["(ns oops.schema\n  \"The code for runtime conversion of selectors to paths. Note: we prefer hand-written loops for performance reasons.\"\n  (:require-macros [oops.schema]\n                   [oops.helpers :refer [unchecked-aget]]\n                   [oops.debug :refer [debug-assert]]\n                   [oops.constants :refer [get-dot-access get-soft-access get-punch-access gen-op-get gen-op-set]]))\n\n; implementation here should mimic static versions in schema.clj\n; for performance reasons we don't reuse the same code on cljs side\n\n; --- path utils ------------------------------------------------------------------------------------------------------------\n\n(def escaped-dot-marker \"####ESCAPED-DOT####\")\n(def re-all-escaped-dots (js/RegExp. \"\\\\\\\\\\\\.\" \"g\"))\n(def re-all-escaped-dot-markers (js/RegExp. \"####ESCAPED-DOT####\" \"g\"))\n\n(defn unescape-modifiers [s]\n  (.replace s #\"^\\\\([?!])\" \"$1\"))\n\n(defn parse-selector-element! [element-str arr]\n  (when-not (empty? element-str)\n    (case (first element-str)\n      \"?\" (do\n            (.push arr (get-soft-access))\n            (.push arr (.substring element-str 1)))\n      \"!\" (do\n            (.push arr (get-punch-access))\n            (.push arr (.substring element-str 1)))\n      (do\n        (.push arr (get-dot-access))\n        (.push arr (unescape-modifiers element-str))))))\n\n(defn unescape-dots [s]\n  (.replace s re-all-escaped-dot-markers \".\"))\n\n(defn parse-selector-string! [selector-str arr]\n  (let [elements-arr (.split (.replace selector-str re-all-escaped-dots escaped-dot-marker) \".\")]\n    (loop [items (seq elements-arr)]\n      (when items\n        (parse-selector-element! (unescape-dots (first items)) arr)\n        (recur (next items))))))\n\n(defn coerce-key-dynamically! [key arr]\n  (let [selector-str (name key)]\n    (parse-selector-string! selector-str arr)))\n\n(defn collect-coerced-keys-into-array! [coll arr]\n  (loop [items (seq coll)]                                                                                                    ; note: items is either a seq or nil\n    (when (some? items)\n      (let [item (-first items)]\n        (if (sequential? item)\n          (collect-coerced-keys-into-array! item arr)\n          (coerce-key-dynamically! item arr))\n        (recur (next items))))))\n\n(defn standalone-modifier? [arr i]\n  (and (pos? (unchecked-aget arr i))\n       (= \"\" (unchecked-aget arr (inc i)))))\n\n(defn merge-standalone-modifier! [arr i]\n  (aset arr (+ i 2) (unchecked-aget arr i))                                                                                   ; transfer modifier\n  (.splice arr i 2))                                                                                                          ; remove standalone item\n\n(defn merge-standalone-modifiers! [arr]\n  (let [len (alength arr)]\n    (loop [i (- len 2)]                                                                                                       ; -2 because it makes no sense to potentially merge last item\n      (let [finger (- i 2)]\n        (if (neg? finger)\n          arr\n          (do\n            (when (standalone-modifier? arr finger)\n              (merge-standalone-modifier! arr finger))\n            (recur finger)))))))\n\n(defn prepare-path! [selector arr]\n  (collect-coerced-keys-into-array! selector arr)\n  (merge-standalone-modifiers! arr))\n\n(defn prepare-simple-path! [key arr]\n  (coerce-key-dynamically! key arr))\n\n(defn has-invalid-path-access-mode? [path is-valid?]\n  (loop [items (seq path)]\n    (when items\n      (if (is-valid? (first items))\n        (recur (next (next items)))\n        true))))\n\n; we should mimic check-static-path! here\n(defn check-dynamic-path! [path op]\n  (debug-assert (= (gen-op-get) 0))\n  (debug-assert (= (gen-op-set) 1))\n  (if (empty? path)\n    [:unexpected-empty-selector]\n    (case op\n      0 (when (has-invalid-path-access-mode? path #(not= % (get-punch-access)))\n          [:unexpected-punching-selector])\n      1 (when (has-invalid-path-access-mode? path #(not= % (get-soft-access)))\n          [:unexpected-soft-selector]))))\n"]}