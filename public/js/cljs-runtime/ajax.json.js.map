{"version":3,"sources":["ajax/json.cljc"],"sourcesContent":["(ns ajax.json\n  (:require [ajax.interceptors :refer \n                [map->ResponseFormat]]\n            [ajax.protocols :refer\n                [-body -process-request -process-response -abort -status\n                -get-response-header -status-text -js-ajax-request\n                -was-aborted]]\n            #?@ (:clj  [[cheshire.core :as c]\n                        [clojure.java.io :as io]]))\n  #? (:clj (:import [java.io OutputStreamWriter ByteArrayOutputStream\n                InputStreamReader Closeable OutputStream\n                InputStream])))\n\n;;; NB If you're looking to use the google closure JSON implementation,\n;;; You'll need ajax.goog-json instead\n\n#? (:clj (defn write-json-cheshire [stream data]\n           (c/generate-stream data (io/writer stream))))\n\n#? (:cljs (defn write-json-native [data]\n            (.stringify js/JSON (clj->js data))))\n\n#? (:clj (defn read-json-cheshire [raw keywords? text]\n           ; NB Raw is ignored since it makes no sense in this context\n           (c/parse-stream (io/reader text) keywords?)))\n\n#? (:cljs (defn read-json-native [raw keywords? text]\n               (let [result-raw (.parse js/JSON text)]\n                    (if raw\n                        result-raw\n                        (js->clj result-raw :keywordize-keys keywords?)))))\n\n(defn make-json-request-format [write-json]\n  (fn json-request-format []\n      {:write write-json\n       :content-type \"application/json\"}))\n\n#? (:clj (defn strip-prefix\n           ^InputStream [^String prefix ^InputStream text]\n           (if prefix\n             (let [utf8 (.getBytes prefix \"UTF-8\")]\n               (loop [i 0]\n                 (if (and (< i (alength utf8))\n                          (= (aget utf8 i) (.read text)))\n                   (recur (inc i))\n                   text)))\n             text))\n     :cljs (defn strip-prefix [^String prefix text]\n             (if (and prefix (= 0 (.indexOf text prefix)))\n               (.substring text (.-length prefix))\n               text)))\n\n(defn make-json-response-format [read-json]\n  \"Create a json request format given `read-json` function.\"\n  (fn json-response-format\n    ([] (json-response-format {}))\n    ([{:keys [prefix keywords? raw]}]\n       (map->ResponseFormat\n        {:read (fn json-read-response-format [xhrio] \n            (read-json raw\n                       keywords?\n                       (strip-prefix prefix (-body xhrio))))\n         :description (str \"JSON\"\n                         (if prefix (str \" prefix '\" prefix \"'\"))\n                         (if keywords? \" keywordize\"))\n         :content-type [\"application/json\"]}))))\n\n(def json-response-format\n  \"Returns a JSON response format using the native JSON \n   implementation. Options include\n   :keywords? Returns the keys as keywords\n   :prefix A prefix that needs to be stripped off.  This is to\n   combat JSON hijacking.  If you're using JSON with GET request,\n   you should think about using this.\n   http://stackoverflow.com/questions/2669690/why-does-google-prepend-while1-to-their-json-responses\n   http://haacked.com/archive/2009/06/24/json-hijacking.aspx\"\n    (make-json-response-format \n        #? (:clj read-json-cheshire :cljs read-json-native)))\n\n(def json-request-format \n    (make-json-request-format \n        #? (:clj write-json-cheshire :cljs write-json-native)))\n"],"mappings":";;;;AAmBU,AAAA,AAAMA,AAAmB;AAAzB,AACE,AAAYC,AAAQ,AAACC,AAAQC;;AAM/B,AAAA,AAAMC,AAAkB,AAAI,AAAU;AAAtC,AACK,AAAM,AAAW,AAAQH,AAAQI;AAAjC,AACK,AAAIC;AACAC;;AACA,AAAA,AAACC,AAAQD,AAA4BE;;;AAE7D,AAAA,AAAMC,AAA0B;AAAhC,AACE;AAAA,AAAA,AAAA,AAAA,AAAA,AACYC;;;AAaH,AAAA,AAAMC,AAAsB,AAAO;AAAnC,AACE,AAAI,AAAA,AAAKE;AAAL,AAAA,AAAAD;AAAY,AAAA,AAACE,AAAI,AAAUV,AAAKS;;AAAhCD;;;AACF,AAAYR,AAAK,AAAUS;;AAC3BT;;;AAEf,AAAA,AAAMW,AAA2B;AAAjC,AAAA;AAEE;;;AAAA,AACM,AAAA,AAACO;;AADP;AAAA,AAAA,AAAA,AAAAN;AAAA,AAAA,AAAA,AAAA,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAC,AAAA,AAAAD,AAAA,AAAA,AAAA,AAAA,AAAAE,AAAAC,AAAAH,AAAAA;AAAA,AAAAI,AAAAJ,AAAA,AAEY;AAFZ,AAAAI,AAAAJ,AAAA,AAEmB;AAFnB,AAAAI,AAAAJ,AAAA,AAE6B;AAF7B,AAGK,AAAA,AAAA,AAACM,AACO;AAA+B;AAA/B,AACH,AAAA,AAAWlB;AAAX,AACWG;AADX,AAEW,AAACG,AAAaE,AAAO,AAACe,AAAMC;AAFvC,AAAA,AAAAL,AAAAC,AAAAC,AAAAF,AAAAC,AAAAC,AAACC,AAAAA,AAAAA;;AAFN,AAAA,AAAA,AAAA,AAKe,AAAA,AACG,AAAA,AAAId,AAAO,AAAA,AAAA,AAAiBA,AAC5B,AAAA,AAAA,AAAIL;;AAV3B;;;;;AAAA;;;;;;;;;AAaF;;;;;;;;;;AAAKsB,AASD,AAACf,AACqCZ;AAE1C,AAAK4B,AACD,AAACtB,AACsCV","names":["ajax.json/write-json-native","js/JSON","cljs.core/clj->js","data","ajax.json/read-json-native","text","raw","result-raw","cljs.core.js__GT_clj.cljs$core$IFn$_invoke$arity$variadic","keywords?","ajax.json/make-json-request-format","write-json","ajax.json/strip-prefix","and__4036__auto__","prefix","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","ajax.json/make-json-response-format","p__22893","map__22894","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","ajax$json$make_json_response_format_$_json_response_format.cljs$core$IFn$_invoke$arity$1","ajax.interceptors/map->ResponseFormat","G__22896","G__22897","G__22898","read-json","ajax.protocols/-body","xhrio","ajax.json/json-response-format","ajax.json/json-request-format"]}