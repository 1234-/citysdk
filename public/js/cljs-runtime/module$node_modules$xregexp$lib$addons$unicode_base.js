shadow$provide.module$node_modules$xregexp$lib$addons$unicode_base=function(global,process,require,module,exports,shadow$shims){Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;exports.default=function(XRegExp){function normalize(name){return name.replace(/[- _]+/g,"").toLowerCase()}function charCode(chr){var esc=/^\\[xu](.+)/.exec(chr);return esc?dec(esc[1]):chr.charCodeAt("\\"===chr[0]?1:0)}function invertBmp(range){var output="",lastEnd=-1;XRegExp.forEach(range,/(\\x..|\\u....|\\?[\s\S])(?:-(\\x..|\\u....|\\?[\s\S]))?/,
function(m){var start=charCode(m[1]);start>lastEnd+1&&(output+="\\u".concat(pad4(hex(lastEnd+1))),start>lastEnd+2&&(output+="-\\u".concat(pad4(hex(start-1)))));lastEnd=charCode(m[2]||m[1])});65535>lastEnd&&(output+="\\u".concat(pad4(hex(lastEnd+1))),65534>lastEnd&&(output+="-\\uFFFF"));return output}var unicode={},dec=XRegExp._dec,hex=XRegExp._hex,pad4=XRegExp._pad4;XRegExp.addToken(/\\([pP])(?:{(\^?)([^}]*)}|([A-Za-z]))/,function(match,scope,flags){var isNegated="P"===match[1]||!!match[2],isAstralMode=
-1!==flags.indexOf("A");flags=normalize(match[4]||match[3]);var item=unicode[flags];if("P"===match[1]&&match[2])throw new SyntaxError("Invalid double negation "+match[0]);if(!unicode.hasOwnProperty(flags))throw new SyntaxError("Unknown Unicode token "+match[0]);if(item.inverseOf){flags=normalize(item.inverseOf);if(!unicode.hasOwnProperty(flags))throw new ReferenceError("".concat("Unicode token missing data "+match[0]," -\x3e ").concat(item.inverseOf));item=unicode[flags];isNegated=!isNegated}if(!item.bmp&&
!isAstralMode)throw new SyntaxError("Astral mode required for Unicode token "+match[0]);if(isAstralMode){if("class"===scope)throw new SyntaxError("Astral mode does not support Unicode tokens within character classes");match=isNegated?"a!":"a\x3d";(scope=unicode[flags][match])||(scope=unicode[flags],flags=unicode[flags],isAstralMode="",flags.bmp&&!flags.isBmpLast&&(isAstralMode="[".concat(flags.bmp,"]").concat(flags.astral?"|":"")),flags.astral&&(isAstralMode+=flags.astral),flags.isBmpLast&&flags.bmp&&
(isAstralMode+="".concat(flags.astral?"|":"","[").concat(flags.bmp,"]")),isNegated=isNegated?"(?:(?!".concat(isAstralMode,")(?:[\ud800-\udbff][\udc00-\udfff]|[\x00-ï¿¿]))"):"(?:".concat(isAstralMode,")"),scope=scope[match]=isNegated);return scope}return"class"===scope?isNegated?unicode[flags]["b!"]||(unicode[flags]["b!"]=invertBmp(unicode[flags].bmp)):item.bmp:"".concat((isNegated?"[^":"[")+item.bmp,"]")},{scope:"all",optionalFlags:"A",leadChar:"\\"});XRegExp.addUnicodeData=function(data){var _iteratorNormalCompletion=
!0,_didIteratorError=!1,_iteratorError=void 0;try{for(var _iterator=data[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=!0){var item=_step.value;if(!item.name)throw Error("Unicode token requires name");if(!(item.inverseOf||item.bmp||item.astral))throw Error("Unicode token has no character data "+item.name);unicode[normalize(item.name)]=item;item.alias&&(unicode[normalize(item.alias)]=item)}}catch(err){_didIteratorError=!0,_iteratorError=
err}finally{try{_iteratorNormalCompletion||null==_iterator.return||_iterator.return()}finally{if(_didIteratorError)throw _iteratorError;}}XRegExp.cache.flush("patterns")};XRegExp._getUnicodeProperty=function(name){name=normalize(name);return unicode[name]}};module.exports=exports["default"]}
//# sourceMappingURL=module$node_modules$xregexp$lib$addons$unicode_base.js.map
