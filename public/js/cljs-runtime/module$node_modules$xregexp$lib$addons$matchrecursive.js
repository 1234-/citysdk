shadow$provide.module$node_modules$xregexp$lib$addons$matchrecursive=function(global$jscomp$0,process,require,module,exports,shadow$shims){Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;exports.default=function(XRegExp){function row(name,value,start,end){return{name:name,value:value,start:start,end:end}}XRegExp.matchRecursive=function(str,left,right,flags,options){flags=flags||"";options=options||{};var global=-1!==flags.indexOf("g"),sticky=-1!==flags.indexOf("y"),basicFlags=
flags.replace(/y/g,""),escapeChar=options.escapeChar;options=options.valueNames;var output=[],openTokens=0,delimStart=0,delimEnd=0,lastOuterEnd=0;left=XRegExp(left,basicFlags);right=XRegExp(right,basicFlags);if(escapeChar){if(1<escapeChar.length)throw Error("Cannot use more than one escape character");escapeChar=XRegExp.escape(escapeChar);var esc=new RegExp("(?:".concat(escapeChar,"[\\S\\s]|(?:(?!").concat(XRegExp.union([left,right],"",{conjunction:"or"}).source,")[^").concat(escapeChar,"])+)+"),
flags.replace(/[^imu]+/g,""))}for(;;){escapeChar&&(delimEnd+=(XRegExp.exec(str,esc,delimEnd,"sticky")||[""])[0].length);flags=XRegExp.exec(str,left,delimEnd);basicFlags=XRegExp.exec(str,right,delimEnd);flags&&basicFlags&&(flags.index<=basicFlags.index?basicFlags=null:flags=null);if(flags||basicFlags)delimStart=(flags||basicFlags).index,delimEnd=delimStart+(flags||basicFlags)[0].length;else if(!openTokens)break;if(sticky&&!openTokens&&delimStart>lastOuterEnd)break;if(flags){if(!openTokens){var outerStart=
delimStart;var innerStart=delimEnd}++openTokens}else if(basicFlags&&openTokens){if(!--openTokens&&(options?(options[0]&&outerStart>lastOuterEnd&&output.push(row(options[0],str.slice(lastOuterEnd,outerStart),lastOuterEnd,outerStart)),options[1]&&output.push(row(options[1],str.slice(outerStart,innerStart),outerStart,innerStart)),options[2]&&output.push(row(options[2],str.slice(innerStart,delimStart),innerStart,delimStart)),options[3]&&output.push(row(options[3],str.slice(delimStart,delimEnd),delimStart,
delimEnd))):output.push(str.slice(innerStart,delimStart)),lastOuterEnd=delimEnd,!global))break}else throw Error("Unbalanced delimiter found in string");delimStart===delimEnd&&++delimEnd}global&&!sticky&&options&&options[0]&&str.length>lastOuterEnd&&output.push(row(options[0],str.slice(lastOuterEnd),lastOuterEnd,str.length));return output}};module.exports=exports["default"]}
//# sourceMappingURL=module$node_modules$xregexp$lib$addons$matchrecursive.js.map
